/**
 * This software is released as part of the Pumpernickel project.
 * 
 * All com.pump resources in the Pumpernickel project are distributed under the
 * MIT License:
 * https://raw.githubusercontent.com/mickleness/pumpernickel/master/License.txt
 * 
 * More information about the Pumpernickel project is available here:
 * https://mickleness.github.io/pumpernickel/
 */
package com.pump.showcase;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.Area;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.net.URL;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Random;

import javax.swing.JComboBox;
import javax.swing.JPanel;

import com.pump.blog.ResourceSample;
import com.pump.geom.Clipper;

/**
 * A simple demo program for the Clipper class.
 * <P>
 * This offers both a performance analysis and a GUI-based demo (so you can
 * visually inspect the results).
 * 
 * <!-- ======== START OF AUTOGENERATED SAMPLES ======== -->
 * <p>
 * <img src=
 * "https://raw.githubusercontent.com/mickleness/pumpernickel/master/pump-release/resources/samples/ClipperDemo/sample.png"
 * alt="new&#160;com.pump.geom.ClipperDemo()"> <!-- ======== END OF
 * AUTOGENERATED SAMPLES ======== -->
 */
@ResourceSample(sample = "new com.pump.geom.ClipperDemo()")
public class ClipperDemo extends ShowcaseChartDemo {
	static final GeneralPath[] p = new GeneralPath[5];
	private static final long serialVersionUID = 1L;
	static {
		Random r = new Random(0);
		for (int a = 0; a < p.length; a++) {
			p[a] = new GeneralPath();
			p[a].moveTo((int) (300 * r.nextDouble()),
					(int) (300 * r.nextDouble()));
			int size = 20;
			for (int b = 0; b < size; b++) {
				int t = (int) (3 * r.nextDouble());
				if (t == 0) {
					p[a].lineTo((int) (300 * r.nextDouble()),
							(int) (300 * r.nextDouble()));
				} else if (t == 1) {
					p[a].quadTo((int) (300 * r.nextDouble()),
							(int) (300 * r.nextDouble()),
							(int) (300 * r.nextDouble()),
							(int) (300 * r.nextDouble()));
				} else {
					p[a].curveTo((int) (300 * r.nextDouble()),
							(int) (300 * r.nextDouble()),
							(int) (300 * r.nextDouble()),
							(int) (300 * r.nextDouble()),
							(int) (300 * r.nextDouble()),
							(int) (300 * r.nextDouble()));
				}
			}
			p[a].closePath();
		}
	}

	JComboBox<String> comboBox = new JComboBox<>();
	JPanel panel = new JPanel() {
		private static final long serialVersionUID = 1L;

		Rectangle2D r = new Rectangle2D.Float(100, 100, 100, 100);

		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			Graphics2D g2 = (Graphics2D) g;
			g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
					RenderingHints.VALUE_ANTIALIAS_ON);
			GeneralPath s = p[comboBox.getSelectedIndex()];
			g2.setColor(Color.white);
			g2.fillRect(0, 0, 300, 300);
			g2.setColor(Color.blue);
			g2.fill(s);
			GeneralPath s2 = Clipper.clipToRect(s, null, r);
			g2.setColor(new Color(0, 255, 0, 120));
			g2.fill(s2);
			PathIterator i = s.getPathIterator(null);
			float[] f2 = new float[6];
			g.setColor(Color.red);
			while (i.isDone() == false) {
				int k = i.currentSegment(f2);
				if (k == PathIterator.SEG_MOVETO) {
					g2.fill(new Ellipse2D.Float(f2[0] - 2, f2[1] - 2, 4, 4));
				} else if (k == PathIterator.SEG_LINETO) {
					g2.draw(new Ellipse2D.Float(f2[0] - 2, f2[1] - 2, 4, 4));
				} else if (k == PathIterator.SEG_QUADTO) {
					g2.draw(new Ellipse2D.Float(f2[2] - 2, f2[3] - 2, 4, 4));
				} else if (k == PathIterator.SEG_CUBICTO) {
					g2.draw(new Ellipse2D.Float(f2[4] - 2, f2[5] - 2, 4, 4));
				}
				i.next();
			}
			g2.setColor(new Color(0, 0, 0, 120));
			g2.draw(r);
		}
	};

	public ClipperDemo() {
		super();

		for (int a = 0; a < p.length; a++) {
			comboBox.addItem("Shape #" + (a + 1));
		}
		upperControls.setLayout(new GridBagLayout());
		GridBagConstraints c = new GridBagConstraints();
		c.gridx = 0;
		c.gridy = 0;
		c.weightx = 1;
		c.weighty = 0;
		upperControls.add(comboBox, c);
		c.gridy++;
		comboBox.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				panel.repaint();
			}
		});
		panel.setPreferredSize(new Dimension(300, 300));
		upperControls.add(panel, c);
	}

	@Override
	public String getTitle() {
		return "Clipper Demo";
	}

	@Override
	public URL getHelpURL() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String[] getKeywords() {
		return new String[] { "clip", "performance", "graphics", "rectangle" };
	}

	@Override
	public Class<?>[] getClasses() {
		return new Class[] { Clipper.class };
	}

	private static final String CLIP_TIME = "Clip (Time)";
	private static final String CLIP_MEMORY = "Clip (Memory)";
	private static final String LABEL_AREA = "java.awt.geom.Area class";
	private static final String LABEL_CLIPPER = "com.pump.geom.Clipper class";
	private static final int SAMPLE_COUNT = 10;

	Map<String, Map<String, Long>> data;
	long[] timeSamples = new long[SAMPLE_COUNT];
	long[] memorySamples = new long[SAMPLE_COUNT];
	int sampleCtr = 0;

	@Override
	protected Map<String, Map<String, Long>> collectData(int... params)
			throws Exception {
		if (data == null) {
			data = new HashMap<>();
			data.put(CLIP_TIME, new LinkedHashMap<String, Long>());
			data.put(CLIP_MEMORY, new LinkedHashMap<String, Long>());
		}

		int sampleIndex = params[0];
		boolean useArea = params[1] == 0;

		Rectangle2D rect = new Rectangle(100, 100, 100, 100);
		Area rArea = new Area(rect);

		System.runFinalization();
		System.gc();
		System.runFinalization();
		System.gc();
		long time = System.currentTimeMillis();
		long memory = Runtime.getRuntime().freeMemory();
		for (int a = 0; a < p.length; a++) {
			for (int z = 0; z < 50; z++) {
				if (useArea) {
					Area area = new Area(p[a]);
					area.intersect(rArea);
				} else {
					Clipper.clipToRect(p[a], rect);
				}
			}
		}
		time = System.currentTimeMillis() - time;
		memory = memory - Runtime.getRuntime().freeMemory();

		timeSamples[sampleIndex] = time;
		memorySamples[sampleIndex] = memory;

		if (sampleIndex == timeSamples.length - 1) {
			Arrays.sort(timeSamples);
			Arrays.sort(memorySamples);
			String label = useArea ? LABEL_AREA : LABEL_CLIPPER;
			data.get(CLIP_TIME).put(label, timeSamples[timeSamples.length / 2]);
			data.get(CLIP_MEMORY).put(label,
					memorySamples[memorySamples.length / 2]);

			if (!useArea)
				return data;
		}

		return null;
	}

	@Override
	protected int[] getCollectDataParamLimits() {
		return new int[] { SAMPLE_COUNT, 2 };
	}

}